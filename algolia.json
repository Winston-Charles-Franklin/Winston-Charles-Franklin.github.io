[
  {
    "objectID": "889ed3ede3ab4e2bb0956f405028f5e37c78b5c0",
    "permalink": "/post/java_file_io/",
    "title": "Java文件读写","content": " Java文件读写 Java io流继承关系: // 输入字节流 InputStream ├── FileInputStream // 从文件中读取字节 ├── ByteArrayInputStream // 从字节数组中读取 ├── ObjectInputStream // 反序列化对象 ├── PipedInputStream // 管道流，用于线程间通信 └── FilterInputStream // 装饰流的基类 // 输出字节流 OutputStream ├── FileOutputStream // 写入字节到文件 ├── ByteArrayOutputStream // 写入字节到字节数组 ├── ObjectOutputStream // 序列化对象 ├── PipedOutputStream // 管道流，用于线程间通信 └── FilterOutputStream // 装饰流的基类 // 输入字符流 Reader ├── FileReader // 从文件中读取字符 ├── BufferedReader // 带缓冲的字符输入流 ├── InputStreamReader // 将字节流转换为字符流 └── StringReader // 从字符串中读取 // 输出字符流 Writer ├── FileWriter // 写入字符到文件 ├── BufferedWriter // 带缓冲的字符输出流 ├── OutputStreamWriter // 将字符流转换为字节流 └── StringWriter // 写入字符到字符串 文件读取 InputStream方法:\nint read() 读取一个字节的数据，返回值为 0 到 255 之间的整数。如果到达流的末尾，返回 -1。\tint data = inputStream.read();\nint read(byte[] b) 从输入流中读取字节，并将其存储在字节数组 b 中，返回实际读取的字节数。如果到达流的末尾，返回 -1。\tbyte[] buffer = new byte[1024]; int bytesRead = inputStream.read(buffer);\nint read(byte[] b, int off, int len)\t从输入流中读取最多 len 个字节，并将它们存 …","date": "2025-12-25 20:17:00",
    "updated": "2025-12-25 20:17:00"
  }, 
  {
    "objectID": "9bdbed94ae056c2be81428e38c6cb9aa48085754",
    "permalink": "/post/isctf2025writeup/",
    "title": "ISCTF2025 Write Up","content": " ISCTF2025WP Web b@by n0t1ce b0ard 题目中提到CVE-2024-12233,是code-projects Online Notice Board（版本 ≤ 1.0）中的一个文件上传漏洞，打开靶机，是Online Notice Board首页，点sign up注册，传头像的地方就是该漏洞的点根据源码可知头像会上传到/images/$e(你填的邮箱地址),\n//upload image mkdir(\u0026amp;#34;images/$e\u0026amp;#34;); move_uploaded_file($_FILES[\u0026amp;#39;img\u0026amp;#39;][\u0026amp;#39;tmp_name\u0026amp;#39;],\u0026amp;#34;images/$e/\u0026amp;#34;.$_FILES[\u0026amp;#39;img\u0026amp;#39;][\u0026amp;#39;name\u0026amp;#39;]); 上传一个webshell:\n\u0026amp;lt;?php phpinfo(); ?\u0026amp;gt; 访问后在phpinfo的Environment里得到flag。\n难过的bottle 一个在线解压器，上传后会显示解压的文件，访问后内容会被template渲染存在ssti,\ntry: return template(content) except Exception as e: return f\u0026amp;#34;渲染错误: {str(e)}\u0026amp;#34; 但是黑名单过滤了很多字符，但是’/’,’a’’f’,’g’,’l’没有过滤，可能用到/flag，试了直接用八进制编码，但是会原样输出。这里还会用latin-1编码来读取文件，考虑全角字符来绕过，\ntry: with open(file_path, \u0026amp;#39;r\u0026amp;#39;, encoding=\u0026amp;#39;utf-8\u0026amp;#39;) as f: content = f.read() except: try: with open(file_path, \u0026amp;#39;r\u0026amp;#39;, encoding=\u0026amp;#39;latin-1\u0026amp;#39;) as f: content = f.read() except: return \u0026amp;#34;无法读取文件内容（可能是二进制文件）\u0026amp;#34; 这里中括号里也用半角会提示渲染错误，所以改用八进制编码，在中括号里可以正常用，文件就是没有过滤的/flag.\npayload =\u0026amp;#34;{{ …","date": "2025-12-09 23:09:00",
    "updated": "2025-12-11 21:57:00"
  }, 
  {
    "objectID": "f1e36e9fb80a6f02812049c047df42e0d1b2d69a",
    "permalink": "/post/rsa%E5%88%B7%E9%A2%981/",
    "title": "RSA刷题1","content": " RSA刷题1 攻防世界RSA_gcd 附件中给了两个n,两个c，一个e，\nn: 23220619839642624127208804329329079289273497927351564011985292026254914394833691542552890810511751239656361686073628273309390314881604580204429708461587512500636158161303419916259271078173864800267063540526943181173708108324471815782985626723198144643256432774984884880698594364583949485749575467318173034467846143380574145455195152793742611717169602237969286580028662721065495380192815175057945420182742366791661416822623915523868590710387635935179876275147056396018527260488459333051132720558953142984038635223793992651637708150494964785475065404568844039983381403909341302098773533325080910057845573898984314246089 e: 65537 …","date": "2025-11-24 23:55:00",
    "updated": "2025-11-24 23:55:00"
  }, 
  {
    "objectID": "5f98474743e52347613b2e0c682fa859935c78fa",
    "permalink": "/post/hello/",
    "title": "Hello World","content": "大家好！\n","date": "2025-11-15 23:00:00",
    "updated": "2025-11-15 23:00:00"
  }]